# 手写代码篇

## 深拷贝

```
function deepClone(obj) {
  if (typeof obj !== 'object' || typeof obj === 'null') return obj;
  let newObj = obj instanceof Array  ? [] : {}; // 重点
  for(let key in obj) {
    if (obj.hasOwnProperty(key)) {
      newObj[key] = typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];
    }
  }
  return newObj;
}
```

## 事件防抖，节流

1. 节流
```
let timer = null;
function debounce1(fun, delayTime) {
  if (timer) {
    return;
  }
  timer = setTimeout(() => {
    fun();
    clearTimeout(timer);
    timer = null;
  }, delayTime);
}
```
使用场景：模糊搜索匹配

2. 防抖

```
let timer = null;
function debounce2(fun, delayTime) {
  if (timer) {
    clearTimeout(timer);
    timer = null;
  }
  timer = setTimeout(() => {
    fun();
    clearTimeout(timer);
    timer = null;
  }, delayTime)
}

```
使用场景：防止重复点击（接口调用，用户下载apk）

**区别：** 
节流在用户连续点击的时候仍然会按照延时时间执行，而防抖则需要用户点击操作停止之后才会执行。

## 手写 200个异步任务 控制最多同时100并发执行的大致思路

```
function createPipeFetch(limit, dataArr) {
  let _tmpFetchArr = [];
  function createFetch(data) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(data);
      }, 3000)
    }).then(res => {
      console.log('data', data);
      // 每次执行完，都要向数据中添加新的promise
      dataArr.length > 0 &&  _tmpFetchArr.push(createFetch(dataArr.shift()));
    })
  }
  if (limit < dataArr.length) { // 如果最大并发数大于数组长度
    while(limit > 0) {
      _tmpFetchArr.push(createFetch(dataArr.shift()));
      --limit;
    }
  } else {
    [].concat(dataArr).forEach((item) => {
      _tmpFetchArr.push(createFetch(item));
      dataArr = [];
    })
  }
  return Promise.all(_tmpFetchArr);
}
createPipeFetch(2, [1,2,3,4,5,6,7])
```



