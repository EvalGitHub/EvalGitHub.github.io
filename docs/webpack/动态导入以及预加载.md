# webpack动态导入及预加载

使用webpack构建项目的时候，它提供了些许优化手段，其中常见的就是动态导入

webpack支持两种方式来实现动态代码分割 **import()**，另一种就是 **require.ensuure**

## import动态导入（代码分割）

原理：动态代码分割，可以将某个模块打包为一个单独的bundle.jd，减少单个js文件的体积。

```
getComponent = async () => {
  this.fetch_data();
  const module = await import(/* webpackChunkName:"createElement" */ '@/utils/index');
  module.createElement().then((component:any) => {
    document.body.appendChild(component);
  });
};
```

需要“Syntax Dynamic Import Babel Plugin”的支持

## 预加载

- preload

加载当前页面会用到的模块，希望能提前加载，更快的响应

```
import(/* webpackPreload: true */ 'ChartingLibrary');
```

- prefetch 

当前页面可能会用到的

em：点击按钮会出现弹窗（用户可能点击按钮，可能不点击）

```
import(/* webpackPrefetch: true */ 'LoginModal');
```

### 实现原理

形成link标签

```
<link rel="prefetch" href="comeModule.js" as="script">
<link rel="prefetch" href="main.css" as="style">
// or
<link rel="preload" href="comeModule.js" as="script">
```

### 不同点

- preload加载的资源是当前页面肯定会用到的，而prefetch加载的资源是可能会用到的
- preload的优先级较prefetch高（
    preload是在页面加载的早期阶段就开始获取，在浏览器的主渲染机制介入前就进行预加载
    prefetch是在浏览器空闲时才会去获取）
- preload有同域限制（crossorigin），但是prefetch没有

**note：** 测试了chrome发现并不会阻塞页面的渲染（不会阻塞浏览器的onload事件）

## 关于preload几点注意

- 只是预加载，但是不执行

使用prefetch/preload，只是提前了这个资源加载的时间点，但是并不会执行这个文件，所以针对资源该怎么使用还是怎么使用

以前的
```
<link href="xx.css">
和
<script src="xxx.js">
```
还是要写在相应的位置的，preload只是优化加载而已。

如果想在资源加载完之后立即执行，使用preload的onload事件

```
<link rel="preload" as="style" href="asyncstyle.css" onload="this.rel='stylesheet'">
```

```
<link rel="preload" as="script" href="async_script.js" onload="var script = document.createElement('script'); script.src = this.href; document.body.appendChild(script);">
```

- 当页面上使用到这个资源时候 preload 资源还没下载完，这时候不会造成二次下载，会等待第一次下载并执行脚本
  一旦页面关闭了，它就会立即停止 preload 获取资源，
  即使页面关闭，prefetch 发起的请求仍会进行不会中断

## 判断浏览器是否支持preload

```
let relList = document.createElement('link').relList
relList.supports('preload');
```






